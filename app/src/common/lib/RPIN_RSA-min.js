var dbits; var canary = 244837814094590; var j_lm = ((canary & 16777215) == 15715070); function BigInteger (b, c, a) { if (b != null) { if (typeof b === 'number') { this.fromNumber(b, c, a) } else { if (c == null && typeof b !== 'string') { this.fromString(b, 256) } else { this.fromString(b, c) } } } } function nbi () { return new BigInteger(null) } function am1 (m, j, c, n, k, l) { while (--l >= 0) { var o = j * this[m++] + c[n] + k; k = Math.floor(o / 67108864); c[n++] = o & 67108863 } return k } function am2 (s, h, c, t, l, w) { var m = h & 32767, j = h >> 15; while (--w >= 0) { var u = this[s] & 32767; var n = this[s++] >> 15; var v = j * u + n * m; u = m * u + ((v & 32767) << 15) + c[t] + (l & 1073741823); l = (u >>> 30) + (v >>> 15) + j * n + (l >>> 30); c[t++] = u & 1073741823 } return l } function am3 (s, h, c, t, l, w) { var m = h & 16383, j = h >> 14; while (--w >= 0) { var u = this[s] & 16383; var n = this[s++] >> 14; var v = j * u + n * m; u = m * u + ((v & 16383) << 14) + c[t] + l; l = (u >> 28) + (v >> 14) + j * n; c[t++] = u & 268435455 } return l } if (j_lm && (navigator.appName == 'Microsoft Internet Explorer')) { BigInteger.prototype.am = am2; dbits = 30 } else { if (j_lm && (navigator.appName != 'Netscape')) { BigInteger.prototype.am = am1; dbits = 26 } else { BigInteger.prototype.am = am3; dbits = 28 } }BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = ((1 << dbits) - 1); BigInteger.prototype.DV = (1 << dbits); var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP); BigInteger.prototype.F1 = BI_FP - dbits; BigInteger.prototype.F2 = 2 * dbits - BI_FP; var BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz'; var BI_RC = new Array(); var rr, vv; rr = '0'.charCodeAt(0); for (vv = 0; vv <= 9; ++vv) { BI_RC[rr++] = vv }rr = 'a'.charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv }rr = 'A'.charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } function int2char (b) { return BI_RM.charAt(b) } function intAt (c, e) { var f = BI_RC[c.charCodeAt(e)]; return (f == null) ? -1 : f } function bnpCopyTo (c) { for (var d = this.t - 1; d >= 0; --d) { c[d] = this[d] }c.t = this.t; c.s = this.s } function bnpFromInt (b) { this.t = 1; this.s = (b < 0) ? -1 : 0; if (b > 0) { this[0] = b } else { if (b < -1) { this[0] = b + DV } else { this.t = 0 } } } function nbv (d) { var c = nbi(); c.fromInt(d); return c } function bnpFromString (j, o) { var m; if (o == 16) { m = 4 } else { if (o == 8) { m = 3 } else { if (o == 256) { m = 8 } else { if (o == 2) { m = 1 } else { if (o == 32) { m = 5 } else { if (o == 4) { m = 2 } else { this.fromRadix(j, o); return } } } } } } this.t = 0; this.s = 0; var k = j.length, n = false, l = 0; while (--k >= 0) { var b = (m == 8) ? j[k] & 255 : intAt(j, k); if (b < 0) { if (j.charAt(k) == '-') { n = true } continue }n = false; if (l == 0) { this[this.t++] = b } else { if (l + m > this.DB) { this[this.t - 1] |= (b & ((1 << (this.DB - l)) - 1)) << l; this[this.t++] = (b >> (this.DB - l)) } else { this[this.t - 1] |= b << l } }l += m; if (l >= this.DB) { l -= this.DB } } if (m == 8 && (j[0] & 128) != 0) { this.s = -1; if (l > 0) { this[this.t - 1] |= ((1 << (this.DB - l)) - 1) << l } } this.clamp(); if (n) { BigInteger.ZERO.subTo(this, this) } } function bnpClamp () { var b = this.s & this.DM; while (this.t > 0 && this[this.t - 1] == b) { --this.t } } function bnToString (q) { if (this.s < 0) { return '-' + this.negate().toString(q) } var p; if (q == 16) { p = 4 } else { if (q == 8) { p = 3 } else { if (q == 2) { p = 1 } else { if (q == 32) { p = 5 } else { if (q == 4) { p = 2 } else { return this.toRadix(q) } } } } } var n = (1 << p) - 1, d, b = false, m = '', o = this.t; var k = this.DB - (o * this.DB) % p; if (o-- > 0) { if (k < this.DB && (d = this[o] >> k) > 0) { b = true; m = int2char(d) } while (o >= 0) { if (k < p) { d = (this[o] & ((1 << k) - 1)) << (p - k); d |= this[--o] >> (k += this.DB - p) } else { d = (this[o] >> (k -= p)) & n; if (k <= 0) { k += this.DB; --o } } if (d > 0) { b = true } if (b) { m += int2char(d) } } } return b ? m : '0' } function bnNegate () { var b = nbi(); BigInteger.ZERO.subTo(this, b); return b } function bnAbs () { return (this.s < 0) ? this.negate() : this } function bnCompareTo (a) { var e = this.s - a.s; if (e != 0) { return e } var f = this.t; e = f - a.t; if (e != 0) { return e } while (--f >= 0) { if ((e = this[f] - a[f]) != 0) { return e } } return 0 } function nbits (e) { var f = 1, d; if ((d = e >>> 16) != 0) { e = d; f += 16 } if ((d = e >> 8) != 0) { e = d; f += 8 } if ((d = e >> 4) != 0) { e = d; f += 4 } if ((d = e >> 2) != 0) { e = d; f += 2 } if ((d = e >> 1) != 0) { e = d; f += 1 } return f } function bnBitLength () { if (this.t <= 0) { return 0 } return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM)) } function bnpDLShiftTo (f, d) { var e; for (e = this.t - 1; e >= 0; --e) { d[e + f] = this[e] } for (e = f - 1; e >= 0; --e) { d[e] = 0 }d.t = this.t + f; d.s = this.s } function bnpDRShiftTo (f, d) { for (var e = f; e < this.t; ++e) { d[e - f] = this[e] }d.t = Math.max(this.t - f, 0); d.s = this.s } function bnpLShiftTo (l, p) { var c = l % this.DB; var k = this.DB - c; var n = (1 << k) - 1; var o = Math.floor(l / this.DB), m = (this.s << c) & this.DM, q; for (q = this.t - 1; q >= 0; --q) { p[q + o + 1] = (this[q] >> k) | m; m = (this[q] & n) << c } for (q = o - 1; q >= 0; --q) { p[q] = 0 }p[o] = m; p.t = this.t + o + 1; p.s = this.s; p.clamp() } function bnpRShiftTo (k, n) { n.s = this.s; var m = Math.floor(k / this.DB); if (m >= this.t) { n.t = 0; return } var h = k % this.DB; var j = this.DB - h; var l = (1 << h) - 1; n[0] = this[m] >> h; for (var o = m + 1; o < this.t; ++o) { n[o - m - 1] |= (this[o] & l) << j; n[o - m] = this[o] >> h } if (h > 0) { n[this.t - m - 1] |= (this.s & l) << j }n.t = this.t - m; n.clamp() } function bnpSubTo (k, h) { var j = 0, c = 0, a = Math.min(k.t, this.t); while (j < a) { c += this[j] - k[j]; h[j++] = c & this.DM; c >>= this.DB } if (k.t < this.t) { c -= k.s; while (j < this.t) { c += this[j]; h[j++] = c & this.DM; c >>= this.DB }c += this.s } else { c += this.s; while (j < k.t) { c -= k[j]; h[j++] = c & this.DM; c >>= this.DB }c -= k.s }h.s = (c < 0) ? -1 : 0; if (c < -1) { h[j++] = this.DV + c } else { if (c > 0) { h[j++] = c } }h.t = j; h.clamp() } function bnpMultiplyTo (k, h) { var a = this.abs(), g = k.abs(); var j = a.t; h.t = j + g.t; while (--j >= 0) { h[j] = 0 } for (j = 0; j < g.t; ++j) { h[j + a.t] = a.am(0, g[j], h, j, 0, a.t) }h.s = 0; h.clamp(); if (this.s != k.s) { BigInteger.ZERO.subTo(h, h) } } function bnpSquareTo (h) { var f = this.abs(); var c = h.t = 2 * f.t; while (--c >= 0) { h[c] = 0 } for (c = 0; c < f.t - 1; ++c) { var g = f.am(c, f[c], h, 2 * c, 0, 1); if ((h[c + f.t] += f.am(c + 1, 2 * f[c], h, 2 * c + 1, g, f.t - c - 1)) >= f.DV) { h[c + f.t] -= f.DV; h[c + f.t + 1] = 1 } } if (h.t > 0) { h[h.t - 1] += f.am(c, f[c], h, 2 * c, 0, 1) }h.s = 0; h.clamp() } function bnpDivRemTo (D, G, H) { var m = D.abs(); if (m.t <= 0) { return } var F = this.abs(); if (F.t < m.t) { if (G != null) { G.fromInt(0) } if (H != null) { this.copyTo(H) } return } if (H == null) { H = nbi() } var J = nbi(), M = this.s, E = D.s; var q = this.DB - nbits(m[m.t - 1]); if (q > 0) { m.lShiftTo(q, J); F.lShiftTo(q, H) } else { m.copyTo(J); F.copyTo(H) } var B = J.t; var L = J[B - 1]; if (L == 0) { return } var C = L * (1 << this.F1) + ((B > 1) ? J[B - 2] >> this.F2 : 0); var y = this.FV / C, e = (1 << this.F1) / C, j = 1 << this.F2; var r = H.t, t = r - B, I = (G == null) ? nbi() : G; J.dlShiftTo(t, I); if (H.compareTo(I) >= 0) { H[H.t++] = 1; H.subTo(I, H) }BigInteger.ONE.dlShiftTo(B, I); I.subTo(J, J); while (J.t < B) { J[J.t++] = 0 } while (--t >= 0) { var K = (H[--r] == L) ? this.DM : Math.floor(H[r] * y + (H[r - 1] + j) * e); if ((H[r] += J.am(0, K, H, t, 0, B)) < K) { J.dlShiftTo(t, I); H.subTo(I, H); while (H[r] < --K) { H.subTo(I, H) } } } if (G != null) { H.drShiftTo(B, G); if (M != E) { BigInteger.ZERO.subTo(G, G) } }H.t = B; H.clamp(); if (q > 0) { H.rShiftTo(q, H) } if (M < 0) { BigInteger.ZERO.subTo(H, H) } } function bnMod (a) { var d = nbi(); this.abs().divRemTo(a, null, d); if (this.s < 0 && d.compareTo(BigInteger.ZERO) > 0) { a.subTo(d, d) } return d } function Classic (b) { this.m = b } function cConvert (b) { if (b.s < 0 || b.compareTo(this.m) >= 0) { return b.mod(this.m) } else { return b } } function cRevert (b) { return b } function cReduce (b) { b.divRemTo(this.m, null, b) } function cMulTo (e, f, d) { e.multiplyTo(f, d); this.reduce(d) } function cSqrTo (d, c) { d.squareTo(c); this.reduce(c) }Classic.prototype.convert = cConvert; Classic.prototype.revert = cRevert; Classic.prototype.reduce = cReduce; Classic.prototype.mulTo = cMulTo; Classic.prototype.sqrTo = cSqrTo; function bnpInvDigit () { if (this.t < 1) { return 0 } var d = this[0]; if ((d & 1) == 0) { return 0 } var c = d & 3; c = (c * (2 - (d & 15) * c)) & 15; c = (c * (2 - (d & 255) * c)) & 255; c = (c * (2 - (((d & 65535) * c) & 65535))) & 65535; c = (c * (2 - d * c % this.DV)) % this.DV; return (c > 0) ? this.DV - c : -c } function Montgomery (b) { this.m = b; this.mp = b.invDigit(); this.mpl = this.mp & 32767; this.mph = this.mp >> 15; this.um = (1 << (b.DB - 15)) - 1; this.mt2 = 2 * b.t } function montConvert (d) { var c = nbi(); d.abs().dlShiftTo(this.m.t, c); c.divRemTo(this.m, null, c); if (d.s < 0 && c.compareTo(BigInteger.ZERO) > 0) { this.m.subTo(c, c) } return c } function montRevert (d) { var c = nbi(); d.copyTo(c); this.reduce(c); return c } function montReduce (f) { while (f.t <= this.mt2) { f[f.t++] = 0 } for (var h = 0; h < this.m.t; ++h) { var e = f[h] & 32767; var g = (e * this.mpl + (((e * this.mph + (f[h] >> 15) * this.mpl) & this.um) << 15)) & f.DM; e = h + this.m.t; f[e] += this.m.am(0, g, f, h, 0, this.m.t); while (f[e] >= f.DV) { f[e] -= f.DV; f[++e]++ } }f.clamp(); f.drShiftTo(this.m.t, f); if (f.compareTo(this.m) >= 0) { f.subTo(this.m, f) } } function montSqrTo (d, c) { d.squareTo(c); this.reduce(c) } function montMulTo (e, f, d) { e.multiplyTo(f, d); this.reduce(d) }Montgomery.prototype.convert = montConvert; Montgomery.prototype.revert = montRevert; Montgomery.prototype.reduce = montReduce; Montgomery.prototype.mulTo = montMulTo; Montgomery.prototype.sqrTo = montSqrTo; function bnpIsEven () { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0 } function bnpExp (l, k) { if (l > 4294967295 || l < 1) { return BigInteger.ONE } var m = nbi(), g = nbi(), n = k.convert(this), o = nbits(l) - 1; n.copyTo(m); while (--o >= 0) { k.sqrTo(m, g); if ((l & (1 << o)) > 0) { k.mulTo(g, n, m) } else { var e = m; m = g; g = e } } return k.revert(m) } function bnModPowInt (d, e) { var f; if (d < 256 || e.isEven()) { f = new Classic(e) } else { f = new Montgomery(e) } return this.exp(d, f) }BigInteger.prototype.copyTo = bnpCopyTo; BigInteger.prototype.fromInt = bnpFromInt; BigInteger.prototype.fromString = bnpFromString; BigInteger.prototype.clamp = bnpClamp; BigInteger.prototype.dlShiftTo = bnpDLShiftTo; BigInteger.prototype.drShiftTo = bnpDRShiftTo; BigInteger.prototype.lShiftTo = bnpLShiftTo; BigInteger.prototype.rShiftTo = bnpRShiftTo; BigInteger.prototype.subTo = bnpSubTo; BigInteger.prototype.multiplyTo = bnpMultiplyTo; BigInteger.prototype.squareTo = bnpSquareTo; BigInteger.prototype.divRemTo = bnpDivRemTo; BigInteger.prototype.invDigit = bnpInvDigit; BigInteger.prototype.isEven = bnpIsEven; BigInteger.prototype.exp = bnpExp; BigInteger.prototype.toString = bnToString; BigInteger.prototype.negate = bnNegate; BigInteger.prototype.abs = bnAbs; BigInteger.prototype.compareTo = bnCompareTo; BigInteger.prototype.bitLength = bnBitLength; BigInteger.prototype.mod = bnMod; BigInteger.prototype.modPowInt = bnModPowInt; BigInteger.ZERO = nbv(0); BigInteger.ONE = nbv(1); function bnClone () { var b = nbi(); this.copyTo(b); return b } function bnIntValue () { if (this.s < 0) { if (this.t == 1) { return this[0] - this.DV } else { if (this.t == 0) { return -1 } } } else { if (this.t == 1) { return this[0] } else { if (this.t == 0) { return 0 } } } return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0] } function bnByteValue () { return (this.t == 0) ? this.s : (this[0] << 24) >> 24 } function bnShortValue () { return (this.t == 0) ? this.s : (this[0] << 16) >> 16 } function bnpChunkSize (b) { return Math.floor(Math.LN2 * this.DB / Math.log(b)) } function bnSigNum () { if (this.s < 0) { return -1 } else { if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) { return 0 } else { return 1 } } } function bnpToRadix (n) { if (n == null) { n = 10 } if (this.signum() == 0 || n < 2 || n > 36) { return '0' } var l = this.chunkSize(n); var m = Math.pow(n, l); var b = nbv(m), a = nbi(), d = nbi(), k = ''; this.divRemTo(b, a, d); while (a.signum() > 0) { k = (m + d.intValue()).toString(n).substr(1) + k; a.divRemTo(b, a, d) } return d.intValue().toString(n) + k } function bnpFromRadix (b, n) { this.fromInt(0); if (n == null) { n = 10 } var p = this.chunkSize(n); var o = Math.pow(n, p), q = false, s = 0, d = 0; for (var r = 0; r < b.length; ++r) { var j = intAt(b, r); if (j < 0) { if (b.charAt(r) == '-' && this.signum() == 0) { q = true } continue }d = n * d + j; if (++s >= p) { this.dMultiply(o); this.dAddOffset(d, 0); s = 0; d = 0 } } if (s > 0) { this.dMultiply(Math.pow(n, s)); this.dAddOffset(d, 0) } if (q) { BigInteger.ZERO.subTo(this, this) } } function bnpFromNumber (c, j, a) { if (typeof j === 'number') { if (c < 2) { this.fromInt(1) } else { this.fromNumber(c, a); if (!this.testBit(c - 1)) { this.bitwiseTo(BigInteger.ONE.shiftLeft(c - 1), op_or, this) } if (this.isEven()) { this.dAddOffset(1, 0) } while (!this.isProbablePrime(j)) { this.dAddOffset(2, 0); if (this.bitLength() > c) { this.subTo(BigInteger.ONE.shiftLeft(c - 1), this) } } } } else { var k = new Array(), b = c & 7; k.length = (c >> 3) + 1; j.nextBytes(k); if (b > 0) { k[0] &= ((1 << b) - 1) } else { k[0] = 0 } this.fromString(k, 256) } } function bnToByteArray () { var d = this.t, k = new Array(); k[0] = this.s; var j = this.DB - (d * this.DB) % 8, h, g = 0; if (d-- > 0) { if (j < this.DB && (h = this[d] >> j) != (this.s & this.DM) >> j) { k[g++] = h | (this.s << (this.DB - j)) } while (d >= 0) { if (j < 8) { h = (this[d] & ((1 << j) - 1)) << (8 - j); h |= this[--d] >> (j += this.DB - 8) } else { h = (this[d] >> (j -= 8)) & 255; if (j <= 0) { j += this.DB; --d } } if ((h & 128) != 0) { h |= -256 } if (g == 0 && (this.s & 128) != (h & 128)) { ++g } if (g > 0 || h != this.s) { k[g++] = h } } } return k } function bnEquals (a) { return (this.compareTo(a) == 0) } function bnMin (a) { return (this.compareTo(a) < 0) ? this : a } function bnMax (a) { return (this.compareTo(a) > 0) ? this : a } function bnpBitwiseTo (m, f, k) { var l, j, a = Math.min(m.t, this.t); for (l = 0; l < a; ++l) { k[l] = f(this[l], m[l]) } if (m.t < this.t) { j = m.s & this.DM; for (l = a; l < this.t; ++l) { k[l] = f(this[l], j) }k.t = this.t } else { j = this.s & this.DM; for (l = a; l < m.t; ++l) { k[l] = f(j, m[l]) }k.t = m.t }k.s = f(this.s, m.s); k.clamp() } function op_and (d, c) { return d & c } function bnAnd (a) { var d = nbi(); this.bitwiseTo(a, op_and, d); return d } function op_or (d, c) { return d | c } function bnOr (a) { var d = nbi(); this.bitwiseTo(a, op_or, d); return d } function op_xor (d, c) { return d ^ c } function bnXor (a) { var d = nbi(); this.bitwiseTo(a, op_xor, d); return d } function op_andnot (d, c) { return d & ~c } function bnAndNot (a) { var d = nbi(); this.bitwiseTo(a, op_andnot, d); return d } function bnNot () { var c = nbi(); for (var d = 0; d < this.t; ++d) { c[d] = this.DM & ~this[d] }c.t = this.t; c.s = ~this.s; return c } function bnShiftLeft (c) { var d = nbi(); if (c < 0) { this.rShiftTo(-c, d) } else { this.lShiftTo(c, d) } return d } function bnShiftRight (c) { var d = nbi(); if (c < 0) { this.lShiftTo(-c, d) } else { this.rShiftTo(c, d) } return d } function lbit (d) { if (d == 0) { return -1 } var c = 0; if ((d & 65535) == 0) { d >>= 16; c += 16 } if ((d & 255) == 0) { d >>= 8; c += 8 } if ((d & 15) == 0) { d >>= 4; c += 4 } if ((d & 3) == 0) { d >>= 2; c += 2 } if ((d & 1) == 0) { ++c } return c } function bnGetLowestSetBit () { for (var b = 0; b < this.t; ++b) { if (this[b] != 0) { return b * this.DB + lbit(this[b]) } } if (this.s < 0) { return this.t * this.DB } return -1 } function cbit (d) { var c = 0; while (d != 0) { d &= d - 1; ++c } return c } function bnBitCount () { var f = 0, e = this.s & this.DM; for (var d = 0; d < this.t; ++d) { f += cbit(this[d] ^ e) } return f } function bnTestBit (c) { var d = Math.floor(c / this.DB); if (d >= this.t) { return (this.s != 0) } return ((this[d] & (1 << (c % this.DB))) != 0) } function bnpChangeBit (f, d) { var e = BigInteger.ONE.shiftLeft(f); this.bitwiseTo(e, d, e); return e } function bnSetBit (b) { return this.changeBit(b, op_or) } function bnClearBit (b) { return this.changeBit(b, op_andnot) } function bnFlipBit (b) { return this.changeBit(b, op_xor) } function bnpAddTo (k, h) { var j = 0, c = 0, a = Math.min(k.t, this.t); while (j < a) { c += this[j] + k[j]; h[j++] = c & this.DM; c >>= this.DB } if (k.t < this.t) { c += k.s; while (j < this.t) { c += this[j]; h[j++] = c & this.DM; c >>= this.DB }c += this.s } else { c += this.s; while (j < k.t) { c += k[j]; h[j++] = c & this.DM; c >>= this.DB }c += k.s }h.s = (c < 0) ? -1 : 0; if (c > 0) { h[j++] = c } else { if (c < -1) { h[j++] = this.DV + c } }h.t = j; h.clamp() } function bnAdd (a) { var d = nbi(); this.addTo(a, d); return d } function bnSubtract (a) { var d = nbi(); this.subTo(a, d); return d } function bnMultiply (a) { var d = nbi(); this.multiplyTo(a, d); return d } function bnDivide (a) { var d = nbi(); this.divRemTo(a, d, null); return d } function bnRemainder (a) { var d = nbi(); this.divRemTo(a, null, d); return d } function bnDivideAndRemainder (a) { var e = nbi(), f = nbi(); this.divRemTo(a, e, f); return new Array(e, f) } function bnpDMultiply (b) { this[this.t] = this.am(0, b - 1, this, 0, 0, this.t); ++this.t; this.clamp() } function bnpDAddOffset (c, d) { while (this.t <= d) { this[this.t++] = 0 } this[d] += c; while (this[d] >= this.DV) { this[d] -= this.DV; if (++d >= this.t) { this[this.t++] = 0 }++this[d] } } function NullExp () {} function nNop (b) { return b } function nMulTo (e, f, d) { e.multiplyTo(f, d) } function nSqrTo (d, c) { d.squareTo(c) }NullExp.prototype.convert = nNop; NullExp.prototype.revert = nNop; NullExp.prototype.mulTo = nMulTo; NullExp.prototype.sqrTo = nSqrTo; function bnPow (b) { return this.exp(b, new NullExp()) } function bnpMultiplyLowerTo (a, g, h) { var j = Math.min(this.t + a.t, g); h.s = 0; h.t = j; while (j > 0) { h[--j] = 0 } var k; for (k = h.t - this.t; j < k; ++j) { h[j + this.t] = this.am(0, a[j], h, j, 0, this.t) } for (k = Math.min(a.t, g); j < k; ++j) { this.am(0, a[j], h, j, 0, g - j) }h.clamp() } function bnpMultiplyUpperTo (a, f, g) { --f; var h = g.t = this.t + a.t - f; g.s = 0; while (--h >= 0) { g[h] = 0 } for (h = Math.max(f - this.t, 0); h < a.t; ++h) { g[this.t + h - f] = this.am(f - h, a[h], g, 0, 0, this.t + h - f) }g.clamp(); g.drShiftTo(1, g) } function Barrett (b) { this.r2 = nbi(); this.q3 = nbi(); BigInteger.ONE.dlShiftTo(2 * b.t, this.r2); this.mu = this.r2.divide(b); this.m = b } function barrettConvert (d) { if (d.s < 0 || d.t > 2 * this.m.t) { return d.mod(this.m) } else { if (d.compareTo(this.m) < 0) { return d } else { var c = nbi(); d.copyTo(c); this.reduce(c); return c } } } function barrettRevert (b) { return b } function barrettReduce (b) { b.drShiftTo(this.m.t - 1, this.r2); if (b.t > this.m.t + 1) { b.t = this.m.t + 1; b.clamp() } this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3); this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); while (b.compareTo(this.r2) < 0) { b.dAddOffset(1, this.m.t + 1) }b.subTo(this.r2, b); while (b.compareTo(this.m) >= 0) { b.subTo(this.m, b) } } function barrettSqrTo (d, c) { d.squareTo(c); this.reduce(c) } function barrettMulTo (e, f, d) { e.multiplyTo(f, d); this.reduce(d) }Barrett.prototype.convert = barrettConvert; Barrett.prototype.revert = barrettRevert; Barrett.prototype.reduce = barrettReduce; Barrett.prototype.mulTo = barrettMulTo; Barrett.prototype.sqrTo = barrettSqrTo; function bnModPow (e, r) { var k = e.bitLength(), n, B = nbv(1), E; if (k <= 0) { return B } else { if (k < 18) { n = 1 } else { if (k < 48) { n = 3 } else { if (k < 144) { n = 4 } else { if (k < 768) { n = 5 } else { n = 6 } } } } } if (k < 8) { E = new Classic(r) } else { if (r.isEven()) { E = new Barrett(r) } else { E = new Montgomery(r) } } var g = new Array(), t = 3, G = n - 1, D = (1 << n) - 1; g[1] = E.convert(this); if (n > 1) { var j = nbi(); E.sqrTo(g[1], j); while (t <= D) { g[t] = nbi(); E.mulTo(j, g[t - 2], g[t]); t += 2 } } var m = e.t - 1, C, F = true, w = nbi(), z; k = nbits(e[m]) - 1; while (m >= 0) { if (k >= G) { C = (e[m] >> (k - G)) & D } else { C = (e[m] & ((1 << (k + 1)) - 1)) << (G - k); if (m > 0) { C |= e[m - 1] >> (this.DB + k - G) } }t = n; while ((C & 1) == 0) { C >>= 1; --t } if ((k -= t) < 0) { k += this.DB; --m } if (F) { g[C].copyTo(B); F = false } else { while (t > 1) { E.sqrTo(B, w); E.sqrTo(w, B); t -= 2 } if (t > 0) { E.sqrTo(B, w) } else { z = B; B = w; w = z }E.mulTo(w, g[C], B) } while (m >= 0 && (e[m] & (1 << k)) == 0) { E.sqrTo(B, w); z = B; B = w; w = z; if (--k < 0) { k = this.DB - 1; --m } } } return E.revert(B) } function bnGCD (m) { var a = (this.s < 0) ? this.negate() : this.clone(); var g = (m.s < 0) ? m.negate() : m.clone(); if (a.compareTo(g) < 0) { var k = a; a = g; g = k } var l = a.getLowestSetBit(), j = g.getLowestSetBit(); if (j < 0) { return a } if (l < j) { j = l } if (j > 0) { a.rShiftTo(j, a); g.rShiftTo(j, g) } while (a.signum() > 0) { if ((l = a.getLowestSetBit()) > 0) { a.rShiftTo(l, a) } if ((l = g.getLowestSetBit()) > 0) { g.rShiftTo(l, g) } if (a.compareTo(g) >= 0) { a.subTo(g, a); a.rShiftTo(1, a) } else { g.subTo(a, g); g.rShiftTo(1, g) } } if (j > 0) { g.lShiftTo(j, g) } return g } function bnpModInt (g) { if (g <= 0) { return 0 } var h = this.DV % g, d = (this.s < 0) ? g - 1 : 0; if (this.t > 0) { if (h == 0) { d = this[0] % g } else { for (var f = this.t - 1; f >= 0; --f) { d = (h * d + this[f]) % g } } } return d } function bnModInverse (o) { var c = o.isEven(); if ((this.isEven() && c) || o.signum() == 0) { return BigInteger.ZERO } var d = o.clone(), m = this.clone(); var n = nbv(1), p = nbv(0), a = nbv(0), b = nbv(1); while (d.signum() != 0) { while (d.isEven()) { d.rShiftTo(1, d); if (c) { if (!n.isEven() || !p.isEven()) { n.addTo(this, n); p.subTo(o, p) }n.rShiftTo(1, n) } else { if (!p.isEven()) { p.subTo(o, p) } }p.rShiftTo(1, p) } while (m.isEven()) { m.rShiftTo(1, m); if (c) { if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(o, b) }a.rShiftTo(1, a) } else { if (!b.isEven()) { b.subTo(o, b) } }b.rShiftTo(1, b) } if (d.compareTo(m) >= 0) { d.subTo(m, d); if (c) { n.subTo(a, n) }p.subTo(b, p) } else { m.subTo(d, m); if (c) { a.subTo(n, a) }b.subTo(p, b) } } if (m.compareTo(BigInteger.ONE) != 0) { return BigInteger.ZERO } if (b.compareTo(o) >= 0) { return b.subtract(o) } if (b.signum() < 0) { b.addTo(o, b) } else { return b } if (b.signum() < 0) { return b.add(o) } else { return b } } var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509]; var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; function bnIsProbablePrime (h) { var j, f = this.abs(); if (f.t == 1 && f[0] <= lowprimes[lowprimes.length - 1]) { for (j = 0; j < lowprimes.length; ++j) { if (f[0] == lowprimes[j]) { return true } } return false } if (f.isEven()) { return false }j = 1; while (j < lowprimes.length) { var g = lowprimes[j], k = j + 1; while (k < lowprimes.length && g < lplim) { g *= lowprimes[k++] }g = f.modInt(g); while (j < k) { if (g % lowprimes[j++] == 0) { return false } } } return f.millerRabin(h) } function bnpMillerRabin (n) { var m = this.subtract(BigInteger.ONE); var q = m.getLowestSetBit(); if (q <= 0) { return false } var k = m.shiftRight(q); n = (n + 1) >> 1; if (n > lowprimes.length) { n = lowprimes.length } var a = nbi(); for (var o = 0; o < n; ++o) { a.fromInt(lowprimes[o]); var j = a.modPow(k, this); if (j.compareTo(BigInteger.ONE) != 0 && j.compareTo(m) != 0) { var p = 1; while (p++ < q && j.compareTo(m) != 0) { j = j.modPowInt(2, this); if (j.compareTo(BigInteger.ONE) == 0) { return false } } if (j.compareTo(m) != 0) { return false } } } return true }BigInteger.prototype.chunkSize = bnpChunkSize; BigInteger.prototype.toRadix = bnpToRadix; BigInteger.prototype.fromRadix = bnpFromRadix; BigInteger.prototype.fromNumber = bnpFromNumber; BigInteger.prototype.bitwiseTo = bnpBitwiseTo; BigInteger.prototype.changeBit = bnpChangeBit; BigInteger.prototype.addTo = bnpAddTo; BigInteger.prototype.dMultiply = bnpDMultiply; BigInteger.prototype.dAddOffset = bnpDAddOffset; BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo; BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo; BigInteger.prototype.modInt = bnpModInt; BigInteger.prototype.millerRabin = bnpMillerRabin; BigInteger.prototype.clone = bnClone; BigInteger.prototype.intValue = bnIntValue; BigInteger.prototype.byteValue = bnByteValue; BigInteger.prototype.shortValue = bnShortValue; BigInteger.prototype.signum = bnSigNum; BigInteger.prototype.toByteArray = bnToByteArray; BigInteger.prototype.equals = bnEquals; BigInteger.prototype.min = bnMin; BigInteger.prototype.max = bnMax; BigInteger.prototype.and = bnAnd; BigInteger.prototype.or = bnOr; BigInteger.prototype.xor = bnXor; BigInteger.prototype.andNot = bnAndNot; BigInteger.prototype.not = bnNot; BigInteger.prototype.shiftLeft = bnShiftLeft; BigInteger.prototype.shiftRight = bnShiftRight; BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit; BigInteger.prototype.bitCount = bnBitCount; BigInteger.prototype.testBit = bnTestBit; BigInteger.prototype.setBit = bnSetBit; BigInteger.prototype.clearBit = bnClearBit; BigInteger.prototype.flipBit = bnFlipBit; BigInteger.prototype.add = bnAdd; BigInteger.prototype.subtract = bnSubtract; BigInteger.prototype.multiply = bnMultiply; BigInteger.prototype.divide = bnDivide; BigInteger.prototype.remainder = bnRemainder; BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder; BigInteger.prototype.modPow = bnModPow; BigInteger.prototype.modInverse = bnModInverse; BigInteger.prototype.pow = bnPow; BigInteger.prototype.gcd = bnGCD; BigInteger.prototype.isProbablePrime = bnIsProbablePrime
/*! Copyright (c) 2009 pidder <www.pidder.com> */
function pidCrypt () { function b (a) { if (!a) { a = 8 } var h = new Array(a); var f = []; for (var g = 0; g < 256; g++) { f[g] = g } for (g = 0; g < h.length; g++) { h[g] = f[Math.floor(Math.random() * f.length)] } return h } this.setDefaults = function () { this.params.nBits = 256; this.params.salt = b(8); this.params.salt = pidCryptUtil.byteArray2String(this.params.salt); this.params.salt = pidCryptUtil.convertToHex(this.params.salt); this.params.blockSize = 16; this.params.UTF8 = true; this.params.A0_PAD = true }; this.debug = true; this.params = {}; this.params.dataIn = ''; this.params.dataOut = ''; this.params.decryptIn = ''; this.params.decryptOut = ''; this.params.encryptIn = ''; this.params.encryptOut = ''; this.params.key = ''; this.params.iv = ''; this.params.clear = true; this.setDefaults(); this.errors = ''; this.warnings = ''; this.infos = ''; this.debugMsg = ''; this.setParams = function (d) { if (!d) { d = {} } for (var a in d) { this.params[a] = d[a] } }; this.getParams = function () { return this.params }; this.getParam = function (a) { return this.params[a] || '' }; this.clearParams = function () { this.params = {} }; this.getNBits = function () { return this.params.nBits }; this.getOutput = function () { return this.params.dataOut }; this.setError = function (a) { this.error = a }; this.appendError = function (a) { this.errors += a; return '' }; this.getErrors = function () { return this.errors }; this.isError = function () { if (this.errors.length > 0) { return true } return false }; this.appendInfo = function (a) { this.infos += a; return '' }; this.getInfos = function () { return this.infos }; this.setDebug = function (a) { this.debug = a }; this.appendDebug = function (a) { this.debugMsg += a; return '' }; this.isDebug = function () { return this.debug }; this.getAllMessages = function (m) { var j = {lf: '\n', clr_mes: false, verbose: 15}; if (!m) { m = j } for (var d in j) { if (typeof (m[d]) === 'undefined') { m[d] = j[d] } } var a = ''; var l = ''; for (var k in this.params) { switch (k) { case 'encryptOut':l = pidCryptUtil.toByteArray(this.params[k].toString()); l = pidCryptUtil.fragment(l.join(), 64, m.lf); break; case 'key':case 'iv':l = pidCryptUtil.formatHex(this.params[k], 48); break; default:l = pidCryptUtil.fragment(this.params[k].toString(), 64, m.lf) }a += '<p><b>' + k + '</b>:<pre>' + l + '</pre></p>' } if (this.debug) { a += 'debug: ' + this.debug + m.lf } if (this.errors.length > 0 && ((m.verbose & 1) == 1)) { a += 'Errors:' + m.lf + this.errors + m.lf } if (this.warnings.length > 0 && ((m.verbose & 2) == 2)) { a += 'Warnings:' + m.lf + this.warnings + m.lf } if (this.infos.length > 0 && ((m.verbose & 4) == 4)) { a += 'Infos:' + m.lf + this.infos + m.lf } if (this.debug && ((m.verbose & 8) == 8)) { a += 'Debug messages:' + m.lf + this.debugMsg + m.lf } if (m.clr_mes) { this.errors = this.infos = this.warnings = this.debug = '' } return a }; this.getRandomBytes = function (a) { return b(a) } }pidCryptUtil = {}; pidCryptUtil.encodeBase64 = function (u, s) { if (!u) { u = '' } var B = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; s = (typeof s === 'undefined') ? false : s; var C, E, F, c, t, x, y, A, z = [], D = '', v, e, w; e = s ? pidCryptUtil.encodeUTF8(u) : u; v = e.length % 3; if (v > 0) { while (v++ < 3) { D += '='; e += '\0' } } for (v = 0; v < e.length; v += 3) { C = e.charCodeAt(v); E = e.charCodeAt(v + 1); F = e.charCodeAt(v + 2); c = C << 16 | E << 8 | F; t = c >> 18 & 63; x = c >> 12 & 63; y = c >> 6 & 63; A = c & 63; z[v / 3] = B.charAt(t) + B.charAt(x) + B.charAt(y) + B.charAt(A) }w = z.join(''); w = w.slice(0, w.length - D.length) + D; return w }; pidCryptUtil.decodeBase64 = function (s, B) { if (!s) { s = '' } var z = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; B = (typeof B === 'undefined') ? false : B; var A, C, D, r, v, x, y, c, w = [], d, t; t = B ? pidCryptUtil.decodeUTF8(s) : s; for (var u = 0; u < t.length; u += 4) { r = z.indexOf(t.charAt(u)); v = z.indexOf(t.charAt(u + 1)); x = z.indexOf(t.charAt(u + 2)); y = z.indexOf(t.charAt(u + 3)); c = r << 18 | v << 12 | x << 6 | y; A = c >>> 16 & 255; C = c >>> 8 & 255; D = c & 255; w[u / 4] = String.fromCharCode(A, C, D); if (y == 64) { w[u / 4] = String.fromCharCode(A, C) } if (x == 64) { w[u / 4] = String.fromCharCode(A) } }d = w.join(''); d = B ? pidCryptUtil.decodeUTF8(d) : d; return d }; pidCryptUtil.encodeUTF8 = function (b) { if (!b) { b = '' }b = b.replace(/[\u0080-\u07ff]/g, function (c) { var a = c.charCodeAt(0); return String.fromCharCode(192 | a >> 6, 128 | a & 63) }); b = b.replace(/[\u0800-\uffff]/g, function (c) { var a = c.charCodeAt(0); return String.fromCharCode(224 | a >> 12, 128 | a >> 6 & 63, 128 | a & 63) }); return b }; pidCryptUtil.decodeUTF8 = function (b) { if (!b) { b = '' }b = b.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function (c) { var a = (c.charCodeAt(0) & 31) << 6 | c.charCodeAt(1) & 63; return String.fromCharCode(a) }); b = b.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (c) { var a = ((c.charCodeAt(0) & 15) << 12) | ((c.charCodeAt(1) & 63) << 6) | (c.charCodeAt(2) & 63); return String.fromCharCode(a) }); return b }; pidCryptUtil.convertToHex = function (g) { if (!g) { g = '' } var h = ''; var f = ''; for (var e = 0; e < g.length; e++) { f = g.charCodeAt(e).toString(16); h += (f.length == 1) ? '0' + f : f } return h }; pidCryptUtil.convertFromHex = function (f) { if (!f) { f = '' } var d = ''; for (var e = 0; e < f.length; e += 2) { d += String.fromCharCode(parseInt(f.substring(e, e + 2), 16)) } return d }; pidCryptUtil.stripLineFeeds = function (c) { if (!c) { c = '' } var d = ''; d = c.replace(/\n/g, ''); d = d.replace(/\r/g, ''); return d }; pidCryptUtil.toByteArray = function (d) { if (!d) { d = '' } var f = []; for (var e = 0; e < d.length; e++) { f[e] = d.charCodeAt(e) } return f }; pidCryptUtil.fragment = function (h, j, g) { if (!h) { h = '' } if (!j || j >= h.length) { return h } if (!g) { g = '\n' } var k = ''; for (var f = 0; f < h.length; f += j) { k += h.substr(f, j) + g } return k }; pidCryptUtil.formatHex = function (j, k) { if (!j) { j = '' } if (!k) { k = 45 } var h = ''; var g = 0; var l = j.toLowerCase(); for (var m = 0; m < l.length; m += 2) { h += l.substr(m, 2) + ':' }l = this.fragment(h, k); return l }; pidCryptUtil.byteArray2String = function (b) { var e = ''; for (var f = 0; f < b.length; f++) { e += String.fromCharCode(b[f]) } return e }; function Arcfour () { this.i = 0; this.j = 0; this.S = new Array() } function ARC4init (g) { var h, f, e; for (h = 0; h < 256; ++h) { this.S[h] = h }f = 0; for (h = 0; h < 256; ++h) { f = (f + this.S[h] + g[h % g.length]) & 255; e = this.S[h]; this.S[h] = this.S[f]; this.S[f] = e } this.i = 0; this.j = 0 } function ARC4next () { var b; this.i = (this.i + 1) & 255; this.j = (this.j + this.S[this.i]) & 255; b = this.S[this.i]; this.S[this.i] = this.S[this.j]; this.S[this.j] = b; return this.S[(b + this.S[this.i]) & 255] }Arcfour.prototype.init = ARC4init; Arcfour.prototype.next = ARC4next; function prng_newstate () { return new Arcfour() } var rng_psize = 256; function Stream (d, c) { if (d instanceof Stream) { this.enc = d.enc; this.pos = d.pos } else { this.enc = d; this.pos = c } }Stream.prototype.parseStringHex = function (h, g) { if (typeof (g) === 'undefined') { g = this.enc.length } var j = ''; for (var f = h; f < g; ++f) { var k = this.get(f); j += this.hexDigits.charAt(k >> 4) + this.hexDigits.charAt(k & 15) } return j }; Stream.prototype.get = function (b) { if (b == undefined) { b = this.pos++ } if (b >= this.enc.length) { throw 'Requesting byte offset ' + b + ' on a stream of length ' + this.enc.length } return this.enc[b] }; Stream.prototype.hexDigits = '0123456789ABCDEF'; Stream.prototype.hexDump = function (h, g) { var j = ''; for (var f = h; f < g; ++f) { var k = this.get(f); j += this.hexDigits.charAt(k >> 4) + this.hexDigits.charAt(k & 15); if ((f & 15) == 7) { j += ' ' }j += ((f & 15) == 15) ? '\n' : ' ' } return j }; Stream.prototype.parseStringISO = function (g, f) { var h = ''; for (var e = g; e < f; ++e) { h += String.fromCharCode(this.get(e)) } return h }; Stream.prototype.parseStringUTF = function (h, g) { var k = '', j = 0; for (var c = h; c < g;) { var j = this.get(c++); if (j < 128) { k += String.fromCharCode(j) } else { if ((j > 191) && (j < 224)) { k += String.fromCharCode(((j & 31) << 6) | (this.get(c++) & 63)) } else { k += String.fromCharCode(((j & 15) << 12) | ((this.get(c++) & 63) << 6) | (this.get(c++) & 63)) } } } return k }; Stream.prototype.reTime = /^((?:1[89]|2\d)?\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/; Stream.prototype.parseTime = function (g, e) { var h = this.parseStringISO(g, e); var f = this.reTime.exec(h); if (!f) { return 'Unrecognized time: ' + h }h = f[1] + '-' + f[2] + '-' + f[3] + ' ' + f[4]; if (f[5]) { h += ':' + f[5]; if (f[6]) { h += ':' + f[6]; if (f[7]) { h += '.' + f[7] } } } if (f[8]) { h += ' UTC'; if (f[8] != 'Z') { h += f[8]; if (f[9]) { h += ':' + f[9] } } } return h }; Stream.prototype.parseInteger = function (g, f) { if ((f - g) > 4) { return undefined } var h = 0; for (var e = g; e < f; ++e) { h = (h << 8) | this.get(e) } return h }; Stream.prototype.parseOID = function (k, j) { var n, l = 0, m = 0; for (var o = k; o < j; ++o) { var h = this.get(o); l = (l << 7) | (h & 127); m += 7; if (!(h & 128)) { if (n == undefined) { n = parseInt(l / 40) + '.' + (l % 40) } else { n += '.' + ((m >= 31) ? 'big' : l) }l = m = 0 }n += String.fromCharCode() } return n }; if (typeof (pidCrypt) !== 'undefined') { pidCrypt.ASN1 = function (j, h, k, g, f) { this.stream = j; this.header = h; this.length = k; this.tag = g; this.sub = f }; pidCrypt.ASN1.prototype.toHexTree = function () { var f = {}; f.type = this.typeName(); if (f.type != 'SEQUENCE') { f.value = this.stream.parseStringHex(this.posContent(), this.posEnd()) } if (this.sub != null) { f.sub = []; for (var d = 0, e = this.sub.length; d < e; ++d) { f.sub[d] = this.sub[d].toHexTree() } } return f }; pidCrypt.ASN1.prototype.typeName = function () { if (this.tag == undefined) { return 'unknown' } var f = this.tag >> 6; var e = (this.tag >> 5) & 1; var d = this.tag & 31; switch (f) { case 0:switch (d) { case 0:return 'EOC'; case 1:return 'BOOLEAN'; case 2:return 'INTEGER'; case 3:return 'BIT_STRING'; case 4:return 'OCTET_STRING'; case 5:return 'NULL'; case 6:return 'OBJECT_IDENTIFIER'; case 7:return 'ObjectDescriptor'; case 8:return 'EXTERNAL'; case 9:return 'REAL'; case 10:return 'ENUMERATED'; case 11:return 'EMBEDDED_PDV'; case 12:return 'UTF8String'; case 16:return 'SEQUENCE'; case 17:return 'SET'; case 18:return 'NumericString'; case 19:return 'PrintableString'; case 20:return 'TeletexString'; case 21:return 'VideotexString'; case 22:return 'IA5String'; case 23:return 'UTCTime'; case 24:return 'GeneralizedTime'; case 25:return 'GraphicString'; case 26:return 'VisibleString'; case 27:return 'GeneralString'; case 28:return 'UniversalString'; case 30:return 'BMPString'; default:return 'Universal_' + d.toString(16) } case 1:return 'Application_' + d.toString(16); case 2:return '[' + d + ']'; case 3:return 'Private_' + d.toString(16) } }; pidCrypt.ASN1.prototype.content = function () { if (this.tag == undefined) { return null } var g = this.tag >> 6; if (g != 0) { return null } var e = this.tag & 31; var h = this.posContent(); var f = Math.abs(this.length); switch (e) { case 1:return (this.stream.get(h) == 0) ? 'false' : 'true'; case 2:return this.stream.parseInteger(h, h + f); case 6:return this.stream.parseOID(h, h + f); case 12:return this.stream.parseStringUTF(h, h + f); case 18:case 19:case 20:case 21:case 22:case 26:return this.stream.parseStringISO(h, h + f); case 23:case 24:return this.stream.parseTime(h, h + f) } return null }; pidCrypt.ASN1.prototype.toString = function () { return this.typeName() + '@' + this.stream.pos + '[header:' + this.header + ',length:' + this.length + ',sub:' + ((this.sub == null) ? 'null' : this.sub.length) + ']' }; pidCrypt.ASN1.prototype.print = function (d) { if (d == undefined) { d = '' }document.writeln(d + this); if (this.sub != null) { d += '  '; for (var f = 0, e = this.sub.length; f < e; ++f) { this.sub[f].print(d) } } }; pidCrypt.ASN1.prototype.toPrettyString = function (e) { if (e == undefined) { e = '' } var g = e + this.typeName() + ' @' + this.stream.pos; if (this.length >= 0) { g += '+' }g += this.length; if (this.tag & 32) { g += ' (constructed)' } else { if (((this.tag == 3) || (this.tag == 4)) && (this.sub != null)) { g += ' (encapsulates)' } }g += '\n'; if (this.sub != null) { e += '  '; for (var h = 0, f = this.sub.length; h < f; ++h) { g += this.sub[h].toPrettyString(e) } } return g }; pidCrypt.ASN1.prototype.toDOM = function () { var r = document.createElement('div'); r.className = 'node'; r.asn1 = this; var m = document.createElement('div'); m.className = 'head'; var k = this.typeName(); m.innerHTML = k; r.appendChild(m); this.head = m; var l = document.createElement('div'); l.className = 'value'; k = 'Offset: ' + this.stream.pos + '<br/>'; k += 'Length: ' + this.header + '+'; if (this.length >= 0) { k += this.length } else { k += (-this.length) + ' (undefined)' } if (this.tag & 32) { k += '<br/>(constructed)' } else { if (((this.tag == 3) || (this.tag == 4)) && (this.sub != null)) { k += '<br/>(encapsulates)' } } var o = this.content(); if (o != null) { k += '<br/>Value:<br/><b>' + o + '</b>'; if ((typeof (oids) === 'object') && (this.tag == 6)) { var q = oids[o]; if (q) { if (q.d) { k += '<br/>' + q.d } if (q.c) { k += '<br/>' + q.c } if (q.w) { k += '<br/>(warning!)' } } } }l.innerHTML = k; r.appendChild(l); var s = document.createElement('div'); s.className = 'sub'; if (this.sub != null) { for (var p = 0, n = this.sub.length; p < n; ++p) { s.appendChild(this.sub[p].toDOM()) } }r.appendChild(s); m.switchNode = r; m.onclick = function () { var a = this.switchNode; a.className = (a.className == 'node collapsed') ? 'node' : 'node collapsed' }; return r }; pidCrypt.ASN1.prototype.posStart = function () { return this.stream.pos }; pidCrypt.ASN1.prototype.posContent = function () { return this.stream.pos + this.header }; pidCrypt.ASN1.prototype.posEnd = function () { return this.stream.pos + this.header + Math.abs(this.length) }; pidCrypt.ASN1.prototype.toHexDOM_sub = function (l, m, k, j, h) { if (j >= h) { return } var g = document.createElement('span'); g.className = m; g.appendChild(document.createTextNode(k.hexDump(j, h))); l.appendChild(g) }; pidCrypt.ASN1.prototype.toHexDOM = function () { var j = document.createElement('span'); j.className = 'hex'; this.head.hexNode = j; this.head.onmouseover = function () { this.hexNode.className = 'hexCurrent' }; this.head.onmouseout = function () { this.hexNode.className = 'hex' }; this.toHexDOM_sub(j, 'tag', this.stream, this.posStart(), this.posStart() + 1); this.toHexDOM_sub(j, (this.length >= 0) ? 'dlen' : 'ulen', this.stream, this.posStart() + 1, this.posContent()); if (this.sub == null) { j.appendChild(document.createTextNode(this.stream.hexDump(this.posContent(), this.posEnd()))) } else { if (this.sub.length > 0) { var h = this.sub[0]; var k = this.sub[this.sub.length - 1]; this.toHexDOM_sub(j, 'intro', this.stream, this.posContent(), h.posStart()); for (var f = 0, g = this.sub.length; f < g; ++f) { j.appendChild(this.sub[f].toHexDOM()) } this.toHexDOM_sub(j, 'outro', this.stream, k.posEnd(), this.posEnd()) } } return j }; pidCrypt.ASN1.decodeLength = function (g) { var e = g.get(); var f = e & 127; if (f == e) { return f } if (f > 3) { throw 'Length over 24 bits not supported at position ' + (g.pos - 1) } if (f == 0) { return -1 }e = 0; for (var h = 0; h < f; ++h) { e = (e << 8) | g.get() } return e }; pidCrypt.ASN1.hasContent = function (h, j, k) { if (h & 32) { return true } if ((h < 3) || (h > 4)) { return false } var l = new Stream(k); if (h == 3) { l.get() } var m = l.get(); if ((m >> 6) & 1) { return false } try { var n = pidCrypt.ASN1.decodeLength(l); return ((l.pos - k.pos) + n == j) } catch (o) { return false } }; pidCrypt.ASN1.decode = function (m) { if (!(m instanceof Stream)) { m = new Stream(m, 0) } var n = new Stream(m); var e = m.get(); var p = pidCrypt.ASN1.decodeLength(m); var q = m.pos - n.pos; var t = null; if (pidCrypt.ASN1.hasContent(e, p, m)) { var s = m.pos; if (e == 3) { m.get() }t = []; if (p >= 0) { var r = s + p; while (m.pos < r) { t[t.length] = pidCrypt.ASN1.decode(m) } if (m.pos != r) { throw 'Content size is not correct for container starting at offset ' + s } } else { try { for (;;) { var l = pidCrypt.ASN1.decode(m); if (l.tag == 0) { break }t[t.length] = l }p = s - m.pos } catch (o) { throw 'Exception while decoding undefined length content: ' + o } } } else { m.pos += p } return new pidCrypt.ASN1(n, q, p, e, t) }; pidCrypt.ASN1.test = function () { var j = [{value: [39], expected: 39}, {value: [129, 201], expected: 201}, {value: [131, 254, 220, 186], expected: 16702650}]; for (var m = 0, h = j.length; m < h; ++m) { var k = 0; var l = new Stream(j[m].value, 0); var g = pidCrypt.ASN1.decodeLength(l); if (g != j[m].expected) { document.write('In test[' + m + '] expected ' + j[m].expected + ' got ' + g + '\n') } } } } function SecureRandom () { this.rng_state; this.rng_pool; this.rng_pptr; this.rng_seed_int = function (a) { this.rng_pool[this.rng_pptr++] ^= a & 255; this.rng_pool[this.rng_pptr++] ^= (a >> 8) & 255; this.rng_pool[this.rng_pptr++] ^= (a >> 16) & 255; this.rng_pool[this.rng_pptr++] ^= (a >> 24) & 255; if (this.rng_pptr >= rng_psize) { this.rng_pptr -= rng_psize } }; this.rng_seed_time = function () { this.rng_seed_int(new Date().getTime()) }; if (this.rng_pool == null) { this.rng_pool = new Array(); this.rng_pptr = 0; var d; if (navigator.appName == 'Netscape' && navigator.appVersion < '5' && window.crypto) { var c = window.crypto.random(32); for (d = 0; d < c.length; ++d) { this.rng_pool[this.rng_pptr++] = c.charCodeAt(d) & 255 } } while (this.rng_pptr < rng_psize) { d = Math.floor(65536 * Math.random()); this.rng_pool[this.rng_pptr++] = d >>> 8; this.rng_pool[this.rng_pptr++] = d & 255 } this.rng_pptr = 0; this.rng_seed_time() } this.rng_get_byte = function () { if (this.rng_state == null) { this.rng_seed_time(); this.rng_state = prng_newstate(); this.rng_state.init(this.rng_pool); for (this.rng_pptr = 0; this.rng_pptr < this.rng_pool.length; ++this.rng_pptr) { this.rng_pool[this.rng_pptr] = 0 } this.rng_pptr = 0 } return this.rng_state.next() }; this.nextBytes = function (a) { var b; for (b = 0; b < a.length; ++b) { a[b] = this.rng_get_byte() } } } if (typeof (pidCrypt) !== 'undefined' && typeof (BigInteger) !== 'undefined' && typeof (SecureRandom) !== 'undefined' && typeof (Arcfour) !== 'undefined') { function parseBigInt (c, d) { return new BigInteger(c, d) } function linebrk (h, g) { var f = ''; var e = 0; while (e + g < h.length) { f += h.substring(e, e + g) + '\n'; e += g } return f + h.substring(e, h.length) } function byte2Hex (b) { if (b < 16) { return '0' + b.toString(16) } else { return b.toString(16) } } function pkcs1unpad2 (h, d) { var b = h.toByteArray(); var j = 0; while (j < b.length && b[j] == 0) { ++j } if (b.length - j != d - 1 || b[j] != 2) { return null }++j; while (b[j] != 0) { if (++j >= b.length) { return null } } var k = ''; while (++j < b.length) { k += String.fromCharCode(b[j] < 0 ? 256 + b[j] : b[j]) } return k } function pkcs1pad2 (l, j) { if (j < l.length + 11) { return null } var k = new Array(); var m = l.length - 1; while (m >= 0 && j > 0) { k[--j] = l.charCodeAt(m--) }k[--j] = 0; var g = new SecureRandom(); var h = new Array(); while (j > 2) { h[0] = 0; while (h[0] == 0) { g.nextBytes(h) }k[--j] = h[0] }k[--j] = 2; k[--j] = 0; return new BigInteger(k) }pidCrypt.RSA = function () { this.n = null; this.e = 0; this.d = null; this.p = null; this.q = null; this.dmp1 = null; this.dmq1 = null; this.coeff = null }; pidCrypt.RSA.prototype.doPrivate = function (e) { if (this.p == null || this.q == null) { return e.modPow(this.d, this.n) } var f = e.mod(this.p).modPow(this.dmp1, this.p); var d = e.mod(this.q).modPow(this.dmq1, this.q); while (f.compareTo(d) < 0) { f = f.add(this.p) } return f.subtract(d).multiply(this.coeff).mod(this.p).multiply(this.q).add(d) }; pidCrypt.RSA.prototype.setPublic = function (f, d, e) { if (typeof (e) === 'undefined') { e = 16 } if (f != null && d != null && f.length > 0 && d.length > 0) { this.n = parseBigInt(f, e); this.e = parseInt(d, e) } else {} }; pidCrypt.RSA.prototype.doPublic = function (b) { return b.modPowInt(this.e, this.n) }; pidCrypt.RSA.prototype.encryptRaw = function (h) { var f = pkcs1pad2(h, (this.n.bitLength() + 7) >> 3); if (f == null) { return null } var g = this.doPublic(f); if (g == null) { return null } var c = g.toString(16); if ((c.length & 1) == 0) { return c } else { return '0' + c } }; pidCrypt.RSA.prototype.encrypt = function (b) { return this.encryptRaw(b) }; pidCrypt.RSA.prototype.decryptRaw = function (c) { var f = parseBigInt(c, 16); var e = this.doPrivate(f); if (e == null) { return null } return pkcs1unpad2(e, (this.n.bitLength() + 7) >> 3) }; pidCrypt.RSA.prototype.setPrivate = function (g, e, h, f) { if (typeof (f) === 'undefined') { f = 16 } if (g != null && e != null && g.length > 0 && e.length > 0) { this.n = parseBigInt(g, f); this.e = parseInt(e, f); this.d = parseBigInt(h, f) } else { alert('Invalid RSA private key') } }; pidCrypt.RSA.prototype.setPrivateEx = function (n, j, r, o, p, k, l, q, m) { if (typeof (m) === 'undefined') { m = 16 } if (n != null && j != null && n.length > 0 && j.length > 0) { this.n = parseBigInt(n, m); this.e = parseInt(j, m); this.d = parseBigInt(r, m); this.p = parseBigInt(o, m); this.q = parseBigInt(p, m); this.dmp1 = parseBigInt(k, m); this.dmq1 = parseBigInt(l, m); this.coeff = parseBigInt(q, m) } else {} }; pidCrypt.RSA.prototype.generate = function (q, j) { var r = new SecureRandom(); var m = q >> 1; this.e = parseInt(j, 16); var p = new BigInteger(j, 16); for (;;) { for (;;) { this.p = new BigInteger(q - m, 1, r); if (this.p.subtract(BigInteger.ONE).gcd(p).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) { break } } for (;;) { this.q = new BigInteger(m, 1, r); if (this.q.subtract(BigInteger.ONE).gcd(p).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) { break } } if (this.p.compareTo(this.q) <= 0) { var k = this.p; this.p = this.q; this.q = k } var l = this.p.subtract(BigInteger.ONE); var o = this.q.subtract(BigInteger.ONE); var n = l.multiply(o); if (n.gcd(p).compareTo(BigInteger.ONE) == 0) { this.n = this.p.multiply(this.q); this.d = p.modInverse(n); this.dmp1 = this.d.mod(l); this.dmq1 = this.d.mod(o); this.coeff = this.q.modInverse(this.p); break } } }; pidCrypt.RSA.prototype.getASNData = function (g) { var h = {}; var k = []; var j = 0; if (g.value && g.type == 'INTEGER') { k[j++] = g.value } if (g.sub) { for (var f = 0; f < g.sub.length; f++) { k = k.concat(this.getASNData(g.sub[f])) } } return k }; pidCrypt.RSA.prototype.setKeyFromASN = function (m, k) { var l = ['N', 'E', 'D', 'P', 'Q', 'DP', 'DQ', 'C']; var j = {}; var h = this.getASNData(k); switch (m) { case 'Public':case 'public':for (var g = 0; g < h.length; g++) { j[l[g]] = h[g].toLowerCase() } this.setPublic(j.N, j.E, 16); break; case 'Private':case 'private':for (var g = 1; g < h.length; g++) { j[l[g - 1]] = h[g].toLowerCase() } this.setPrivateEx(j.N, j.E, j.D, j.P, j.Q, j.DP, j.DQ, j.C, 16); break } }; pidCrypt.RSA.prototype.setPublicKeyFromASN = function (b) { this.setKeyFromASN('public', b) }; pidCrypt.RSA.prototype.setPrivateKeyFromASN = function (b) { this.setKeyFromASN('private', b) }; pidCrypt.RSA.prototype.getParameters = function () { var b = {}; if (this.n != null) { b.n = this.n }b.e = this.e; if (this.d != null) { b.d = this.d } if (this.p != null) { b.p = this.p } if (this.q != null) { b.q = this.q } if (this.dmp1 != null) { b.dmp1 = this.dmp1 } if (this.dmq1 != null) { b.dmq1 = this.dmq1 } if (this.coeff != null) { b.c = this.coeff } return b } } function parsePubkInfoJson (p) { var m = p.replace(/\s+|\n/g, ''); var u = /\"(.*?)\"/g; var q = u.exec(m); if (!/\bversion\b/.test(q[1])) { return null } var t = u.exec(m); if (t[1] == null) { return null } var s = u.exec(m); if (!/\bformat\b/.test(s[1])) { return null } var n = u.exec(m); if (!/\b[0|3]\b/.test(n[1])) { return null } var o = u.exec(m); if (!/\bpublickey\b/.test(o[1])) { return null } var r = u.exec(m); if (r[1] == null) { return null } var l = [t[1], n[1], r[1]]; return l } function format3FillValue () { var b = ['A', 'B', 'C', 'D', 'E', 'F']; return b[Math.floor(Math.random() * 6)] } function createIPinBlock (l, j) { if (l == null) { throw 'Pin can not be null.' } if (l.length < 4 || l.length > 12) { throw 'Pin length must be between 4 and 12.' } if (!/^[0-9]+$/i.test(l)) { throw 'Valid pin values can be from 0 to 9' } if (!/^[03]+$/i.test(j)) { throw 'Valid format values can be 0 or 3' } var h = l.length; pinLenInHex = h.toString(16); var m = 14 - h; var g = ''; if (j == '0') { g = '0' + pinLenInHex + l; for (var k = 0; k < m; k++) { g += 'F' } } else { if (j == '3') { g = '3' + pinLenInHex + l; for (var k = 0; k < m; k++) { g += format3FillValue() } } else { throw 'Invalid pin block format.' } } return g.toUpperCase() } function createPanRefBlock (g, k) { if (g == null) { g = '' } var f = 0; if (k && g.length > 12) { f = 1 } if (g.length - f < 1) { return '0000000000000000' } var h = ''; for (var j = 1; j <= 12; j++) { if (g.length - j - f >= 0) { h = g.charAt(g.length - j - f) + h } else { h = '0' + h } }h = '0000' + h; if (!/^[a-f0-9]+$/i.test(g)) { throw 'Valid PAN Reference can only be hex character [0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]' } return h.toUpperCase() } function hexToBytes (c) { for (var e = [], f = 0; f < c.length; f += 2) { e.push(parseInt(c.substr(f, 2), 16)) } return e } function xorAndConvertToBytes (h, c) { for (var f = [], g = 0; g < h.length; g += 2) { f.push(parseInt(h.substr(g, 2), 16) ^ parseInt(c.substr(g, 2), 16)) } return f } function decimalToString (d) { var c = ''; for (i = 0; i < d.length; i++) { c += d[i].toString(16) } return c.toUpperCase() } function getEncryptedIPB (H, E, z) { var x = null; var B = null; var w = '0'; var K = null; try { if (H == null || H.length < 1) { throw 'publicKey Json can not be null.' } if (/{/i.test(H) && /}/i.test(H)) { var u = parsePubkInfoJson(H); w = u[1]; K = u[2] } else { K = H } if (K == null || K.length < 1) { throw 'publicKey can not be null.' } var v = createIPinBlock(E, w); var J = createPanRefBlock(z, true); var D = xorAndConvertToBytes(v, J); var t = pidCryptUtil.decodeBase64(K); var I = new pidCrypt.RSA(); var C = pidCrypt.ASN1.decode(pidCryptUtil.toByteArray(t)); var y = C.toHexTree(); I.setPublicKeyFromASN(y); var A = pidCryptUtil.byteArray2String(D); var G = I.encrypt(A); x = pidCryptUtil.encodeBase64(pidCryptUtil.convertFromHex(G)) } catch (F) { throw F } return x };
